\documentclass{IFES-beamer}
\usepackage{pgfplots}
\pgfplotsset{compat=1.15}
\usepackage{amssymb}
\usepackage{graphicx,xcolor}
\usepackage{color}
\definecolor{ccqqqq}{rgb}{1,0,0}
\definecolor{darkGreen}{rgb}{0,.5,0}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Defini o estlo no algorithmic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\R}{\mathbb{R}}
\newcommand{\red}{\color{red}}
\newcommand{\green}{\color{green}}
\newcommand{\TODO}[1]{{{\red #1}}}
%\newcommand{\var}[1]{$#1$} %define estilo de nomes de variaveis
\newcommand{\defi}[1]{\textbf{#1}} % defini estilo ao definir algo no texto
\def\Nil{\text{NIL}}

\newcommand\circledmark{%
  \ooalign{%
    \hidewidth
    \kern-0.4ex\raisebox{-2.1ex}{\scalebox{5.5}{\textcolor{darkGreen}{\textbullet}}}
    \hidewidth\cr
    \kern-.6ex\raisebox{.6ex}{\color{white}$\checkmark$}\cr
  }%
}
\newcommand\custommark{%
  \ooalign{%
    \hidewidth
    \kern-0.4ex\raisebox{-2.1ex}{\scalebox{5.5}{\textcolor{white}{\textbullet}}}
    \hidewidth\cr
    \kern-.6ex{\color{black}$\checkmark$}\cr
  }%
}


\usepackage[Algoritmo]{algorithm}
\usepackage[noend]{algpseudocode}
\algrenewcommand\algorithmicif{\textbf{se}}
\algrenewcommand\algorithmicfor{\textbf{para}}
\algrenewcommand\algorithmicelse{\textbf{senão}}
\algrenewcommand\algorithmicwhile{\textbf{enquanto}}
\algrenewcommand\algorithmicdo{\textbf{faça}}
\algrenewcommand\algorithmicend{\textbf{fim}}
\algrenewcommand\algorithmicthen{\textbf{então}}
\algrenewcommand\algorithmicreturn{\textbf{retorne}}



\newcommand{\AlgoName}[1]{\text{\scshape #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Comandos de notação assintotica   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\O}[1]{\text{O}(#1)}
\newcommand{\OTheta}[1]{\Theta(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Nomes de váriaveis      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\varname}[1]{\textit{#1}}
\newcommand{\altvarname}[1]{$#1$}
\newcommand{\node}{\textit{nó}}
\newcommand{\var}{\mathit{var}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de Grafos      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\graphCreate}{\AlgoName{novoGrafo}}
\newcommand{\graphAdd}{\AlgoName{ligueGLA}}
\newcommand{\graphDel}{\AlgoName{removaGLA}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de Treap       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\treapCreate}{\AlgoName{novoNó}}
\newcommand{\treapSearch}{\AlgoName{busca}}
\newcommand{\treapGetLast}{\AlgoName{último}}
\newcommand{\treapGetRoot}{\AlgoName{raiz}}
\newcommand{\treapOrder}{\AlgoName{ordem}}
\newcommand{\treapJoin}{\AlgoName{junta}}
\newcommand{\treapSplit}{\AlgoName{corta}}
\newcommand{\treapSplitRight}{\AlgoName{cortaDireita}}
\newcommand{\treapGetSize}{\AlgoName{tamanho}}
\newcommand{\treapGetEdgesLevel}{\AlgoName{arestasDeNível}}

\newcommand{\treapFirst}{\AlgoName{primeiro}}
\newcommand{\treapLast}{\AlgoName{último}}
\newcommand{\treapPredecessor}{\AlgoName{\AlgoName{Pred}}}    %(F, u, v)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Euler Tour Tree %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ETTCreate}{\AlgoName{novoETT}}     % (v)
\newcommand{\ETTAddEdge}{\AlgoName{ligueETT}} % ($F$, $uu$, $vv$)
\newcommand{\ETTDelEdge}{\AlgoName{removaETT}} % ($F$, $uu$, $vv$)
\newcommand{\ETTQuery}{\AlgoName{conectadoETT}} % ($F$, $uu$, $vv$)
\newcommand{\ETmovetofront}{\AlgoName{movaInício}} % ($F$, $uu$)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos da tabela hash         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\dymForestHash}{$H$}  %simbolo que identifica a matriz/hash da floresta
\newcommand{\nivel}{\AlgoName{nível}} 
\newcommand{\hashCreate}{\AlgoName{novoDicio}}     

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Florestas dinamicas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\dymForestCreate}{\AlgoName{novaFD}}  %(n)
\newcommand{\dymForestAddEdge}{\AlgoName{ligueFD}}    %(F, u, v)
\newcommand{\dymForestDelEdge}{\AlgoName{removaFD}}    %(F, u, v)
\newcommand{\dymForestQuery}{\AlgoName{\AlgoName{conectadoFD}}}    %(F, u, v)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Grafos dinamicas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\dymGraphCreate}{\AlgoName{novoGD}}    %(n)
\newcommand{\dymGraphAddEdge}{\AlgoName{ligueGD}} %(G, u, v)
\newcommand{\dymGraphDelEdge}{\AlgoName{removaGD}} %(G, u, v)
\newcommand{\dymGraphQuery}{\AlgoName{\AlgoName{conectadoGD}}} %(G, u, v)
\newcommand{\dymGraphReplace}{\AlgoName{\AlgoName{substituaGD}}} %(G, u, v, i)
\newcommand{\dymGraphHash}{$H$}  %simbolo que identifica a matriz/hash da floresta

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Link/Cut Tree   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\linkcutCreate}{\AlgoName{newLCT}}
\newcommand{\linkcutDestroy}{\AlgoName{delLCT}}
\newcommand{\linkcutAddEdge}{\AlgoName{link}}    %(F, u, v)
\newcommand{\linkcutDelEdge}{\AlgoName{cut}}    %(F, u, v)
\newcommand{\linkcutEvert}{\AlgoName{\AlgoName{evert}}}    %(v)
\newcommand{\linkcutMax}{\AlgoName{\AlgoName{max}}}    %(F, u, v)
\newcommand{\linkcutMin}{\AlgoName{\AlgoName{min}}}    %(F, u, v)
\newcommand{\linkcutParent}{\AlgoName{\AlgoName{parent}}}    %(F, u, v)
\newcommand{\linkcutQuery}{\AlgoName{\AlgoName{conectadoLC}}}    %(F, u, v)
\newcommand{\linkcutWeight}{\AlgoName{\AlgoName{set weight}}}    %(F, u, v)
\newcommand{\linkcutRoot}{\AlgoName{\AlgoName{get Root}}}    %(F, u, v)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Link/Cut Tree com ordem  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\LCOMakeOcto}{\AlgoName{Create Octo}}
\newcommand{\LCODestroyOcto}{\AlgoName{Destroy Octo}}

\newcommand{\LCOMakeNode}{\AlgoName{Make edge}}
\newcommand{\LCODestroyNode}{\AlgoName{Make edge}}
\newcommand{\LCOLink}{\AlgoName{Link}}
\newcommand{\LCOMerge}{\AlgoName{Merge}}
\newcommand{\LCOSplit}{\AlgoName{Split}}
\newcommand{\LCOCycle}{\AlgoName{Cycle}}
\newcommand{\LCOParent}{\AlgoName{\AlgoName{Parent}}}    %(F, u, v)
\newcommand{\LCORoot}{\AlgoName{Root}}
\newcommand{\LCOAddCost}{\AlgoName{Set weight}}
\newcommand{\LCOMax}{\AlgoName{\AlgoName{Find max}}}    %(F, u, v)
\newcommand{\LCOMin}{\AlgoName{\AlgoName{Find min}}}    %(F, u, v)
\newcommand{\LCOEvert}{\AlgoName{\AlgoName{Evert}}}    %(F, u, v)
\newcommand{\LCOConnected}{\AlgoName{\AlgoName{Connected}}}    %(F, u, v)
\newcommand{\LCOFindNode}{\AlgoName{Find node}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de MSF         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\MSFCreate}{\AlgoName{novoGDP}} %(n)
\newcommand{\MSFupdate}{\AlgoName{mudaPesoGDP}} %(n)
\newcommand{\MSFaddEdge}{\AlgoName{ligueGDP}}    %(G, u, v, w)
\newcommand{\MSFdelEdge}{\AlgoName{removaGDP}}    %(G, u, v)
\newcommand{\MSFweight}{\AlgoName{pesoGDP}}    %(G)

\newcommand{\dymGraphReplaceMSF}{\AlgoName{substituaGDP}} %(G, u, v, i)
\newcommand{\treapGetEdgeMinWeight}{\AlgoName{arestaMinPesoGDP}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de VPSP
% Verify partial sum of permutations%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\VPSPconvert}{\AlgoName{converta}}
\newcommand{\VPSPupdate}{\AlgoName{substitua}}
\newcommand{\VPSPverify}{\AlgoName{verifique}}




% --------------------------------------------------- %
%                  Presentation info	              %
% --------------------------------------------------- %
\title[Algorit. em conexidade dinâmica]{Algoritmos para conexidade em grafos dinâmicos}
%\subtitle{Subtitle}
\author[Arthur Rodrigues]{Arthur Henrique Dias Rodrigues\\{\footnotesize sob orientação de}\\Cristina Gomes Fernandes}
\institute[IME-USP]{
  Instituto de Matemática e Estatistica\\
  USP
}
\day=22
\month=11
\year=2024
\subject{Algorit. em conexidade dinâmica} % metadata

% --------------------------------------------------- %
%                    Title + Schedule                 %
% --------------------------------------------------- %


\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Sumário}
  \tableofcontents
\end{frame}

\iffalse
% --------------------------------------------------- %
%                      Presentation                   %
% --------------------------------------------------- %

\section{Problemas}
\subsection{Definições}
\begin{frame}{Problema de conexidade dinâmicas}
\begin{block}{Contexto}
\begin{itemize}
    \item $G$: grafo;
    \item $n$: número de vértices em~$G$;
    \item $F$: floresta;
    \item $u$,$v$: vértices.
    \end{itemize}
\end{block}

\begin{exampleblock}{Problema de conexidade dinâmicas}
\begin{itemize}
\item \dymGraphCreate($n$): retorna um grafo dinâmico com $n$ vértices isolados;
\item \dymGraphAddEdge($G$, $u$, $v$): adiciona aresta $uv$ a~$G$;
\item \dymGraphDelEdge($G$, $u$, $v$): remove $uv$ de $G$; e
\item \dymGraphQuery($G$, $u$, $v$): retorna verdadeiro se $u$ e~$v$ estão na mesma componente conexa de~$G$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}
\end{frame}

\begin{frame}{Problemas MSF}
\boxblue{MSF: floresta maximal de peso mínimo}
\begin{block}{Grafo ponderado}
Cada aresta possui um peso associado.
\end{block}

\begin{exampleblock}{Problema de floresta maximal de peso mínimo em grafos ponderados planos dinâmicos}
\begin{itemize}
\item \MSFCreate($n$): devolve um grafo ponderado com $n$ vértices isolados;
\item \MSFaddEdge($G$, $u$, $v$, $w$): adiciona a aresta~$uv$ com peso~$w$ em~$G$;
\item \MSFdelEdge($G$, $u$, $v$): remove a aresta $uv$ de $G$; e
\item \MSFweight($G$): devolve o peso de uma MSF de $G$.
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Resultados conhecidos}
\begin{frame}{Resultados conhecidos}
\begin{alertblock}{Limitante inferior (Patrascu e Demaine)~\cite{lowerBoundPatrascu}, 2006}
Todo algoritmo que resolve os problemas de conexidade dinâmica e de MSF dinâmica possuem consumo de tempo~$\Omega(\lg n)$.
\end{alertblock}
\begin{block}{Conexidade dinâmicas~(Holm et al.~\cite{poly_log}, 2001)}
Para árvores,~$\O{\lg n}$;\\
Grafos gerais,~$\O{\lg^2 n}$ amortizado.
\end{block}

\begin{block}{MSF~(Holm et al.~\cite{poly_log}, 2001)}
Para grafos gerais, amortizado~$\O{\lg^4 n}$.
\end{block}
\end{frame}
\fi

% --------------------------------------------------- %
%      Conexidade em florestas dinâmicas              %
% --------------------------------------------------- %
\section{Conexidade em florestas dinâmicas}
\subsection{Definição}
\begin{frame}{Conexidade em florestas dinâmicas}

\begin{exampleblock}{Problema de conexidade em florestas dinâmicas}
\begin{itemize}
\item \dymForestCreate($n$): retorna uma floresta dinâmica com $n$ vértices isolados;
\item \dymForestAddEdge($F$,$u$,$v$): adiciona $uv$ a~$F$;
\item \dymForestDelEdge($F$,$u$,$v$): remove $uv$ de $F$; e
\item \dymForestQuery($F$,$u$,$v$): retorna verdadeiro se $u$ e~$v$ estão na mesma componente conexa de~$F$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Euler Tour Trees}

\begin{frame}{Sequência Euleriana}
\begin{figure}[htb]
\centering
\scalebox{.9}{
\input{fig/exemploSeqEuler.tex}
\input{fig/exemploSeqEulerTransformada.tex}
	}
\end{figure}
\begin{center}
{\large 30~00~04~41~12~22~21~11~14~44~45~55~54~40~03~33}
\end{center}
\end{frame}

\begin{frame}{Euler Tour Trees}
\begin{figure}[htb]
\centering
\scalebox{.7}{
\input{fig/SEQ-INDICES.tex}}
\end{figure}
\begin{center}
{\large 30~00~04~41~12~22~21~11~14~44~45~55~54~40~03~33}
\end{center}
\end{frame}



\begin{frame}{Chaves implícitas}
\begin{figure}[htb]
\scalebox{.7}{
\centering
\input{fig/SEQ-SIZE.tex}}
\end{figure}
\begin{center}
{\large 30~00~04~41~12~22~21~11~14~44~45~55~54~40~03~33}
\end{center}
\end{frame}


\begin{frame}{Biblioteca de Euler Tour Trees}
\begin{exampleblock}{Biblioteca de Euler Tour Trees}
\begin{itemize}
\item  \treapCreate($u$, $v$): retorna uma ABB com um único nó com valor uv;
\item \treapJoin($T$, $R$): junta as ABBs $T$ e $R$ concatenando as sequências Eulerianas armazenada nelas e retorna a raiz da árvore resultante.
\item \treapSplit($\node$): corta a ABB que contém um nó~$\node$ em três ABBs. A primeira ABB contém todos os nós com chave estritamente menor do que a chave de~$\node$, a segunda contém somente~$\node$ e a última contém todos os nós com chave estritamente maior do que a chave de~$\node$. Essa rotina retorna as raízes dessas três ABBs; e
\item \treapGetRoot($x$): retorna a raiz da ABB que contém $x$;
\end{itemize}
\end{exampleblock}
\boxpurple{\centering  \treapCreate{}:~$\O{1}$.\\ As demais operações :~$\O{\lg n}$.}
\end{frame}

\begin{frame}{Tabela de símbolos}
\boxblue{
\centering
Associa $(u,v) \rightarrow uv$.
}
\begin{exampleblock}{Biblioteca de tabela de símbolos}
\begin{itemize}
    \item $F \gets \hashCreate(n)$: cria e retorna um dicionário~$F$ para uma floresta dinâmica com~$n$ vértices;
    \item $F[u,v] \gets uv$: insere o nó que contém $uv$, com chave $(u,v)$ e valor associado~$uv$ na tabela~$F$.
    Se o par~$(u,v)$ já estiver presente no dicionário, então seu valor associado é substituído por~$uv$;
    \item $F[u,v] \gets \Nil{}$: remove o nó associado a~$(u,v)$ e seu valor associado do dicionário~$F$;
    \item $\var{} \gets F[u,v]$: atribui o valor associado à chave~$(u,v)$ à variável~$\var$;
	Caso a chave~$(u,v)$ não esteja presente em~$F$, atribui~$\Nil$ a~$\var{} $.
\end{itemize}
\end{exampleblock}
\boxpurple{
\centering
Consumo esperado~$\O{1}$ por rotina~\cite{CLRS}.
}
\end{frame}

\begin{frame}{Implementação da interface de floresta dinâmica}
\begin{algorithm}[H]
\caption{\dymForestCreate($n$)}
\label{Algo:dymForestCreate}
\begin{algorithmic}[1]
\State $F~\gets~\hashCreate(n)$
\For {$v$ $\gets$ 1 até $n$}\label{Algo:dymForestCreate:for}
\State $F[v,v]~\gets$ \treapCreate($v$, $v$)
\EndFor
\State \Return $F$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\dymForestQuery($F$, $u$, $v$)}
\label{Algo:dymForestQuery}
\begin{algorithmic}[1]
\State \varname{uu} $\gets$ $F[u,u]$
\State $vv$ $\gets$ $F[v,v]$
\State \Return \treapGetRoot(\varname{uu}) = \treapGetRoot($vv$)
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
~~~~~\dymForestCreate{} : $\O{n}$\\
\dymForestQuery{}  : $\O{\lg n}$
}
\end{frame}

\begin{frame}{Implementação da interface de floresta dinâmica}
\begin{algorithm}[H]
\caption{\ETmovetofront($F$,$u$)}
\label{Algo:ETmovetofront}
\begin{algorithmic}[1]
\State \varname{uu} $\gets$ $F[u,u]$\label{Algo:ETmovetofront:1}
\State $A$, \varname{uu}, $B$ $\gets$ \treapSplit(\varname{uu})\label{Algo:ETmovetofront:2}
\State \Return \treapJoin(\varname{uu}, $B$, $A$)\label{Algo:ETmovetofront:3}
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\dymForestAddEdge($F$,$u$,$v$)}
\label{Algo:dymForestAddEdge}
\begin{algorithmic}[1]
\State $U$ $\gets$ \ETmovetofront($F$, $u$)
\State $V$ $\gets$ \ETmovetofront($F$, $v$)
\State $uv$ $\gets$ \treapCreate($u$, $v$)
\State $vu$ $\gets$ \treapCreate($v$, $u$)
\State $F[u,v]$ $\gets$ $uv$
\State $F[v,u]$ $\gets$ $vu$
\State \treapJoin($U$, $uv$, $V$, $vu$)
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
\dymForestAddEdge{}  : $\O{\lg n}$\\
\ETmovetofront{}  : $\O{\lg n}$
}
\end{frame}

\begin{frame}{Implementação da interface de floresta dinâmica}
\begin{algorithm}[H]
\caption{\dymForestDelEdge($F$, $u$, $v$)}
\label{Algo:dymForestDelEdge}
\begin{algorithmic}[1]
\State $uv$ $\gets$ $F[u,v]$\label{Algo:dymForestDelEdge:1}
\State $vu$ $\gets$ $F[v,u]$\label{Algo:dymForestDelEdge:2}
\State $A$, $uv$, $B$ $\gets$ \treapSplit($uv$)\label{Algo:dymForestDelEdge:3}
\State \treapJoin($B$, $A$)\label{Algo:dymForestDelEdge:4}
\State \treapSplit($vu$)\label{Algo:dymForestDelEdge:5}
\State $F[u,v]$ $\gets$ $\Nil{}$\label{Algo:dymForestDelEdge:6}
\State $F[v,u]$ $\gets$ $\Nil{}$\label{Algo:dymForestDelEdge:7}
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
\dymForestDelEdge{}  : $\O{\lg n}$
}
\end{frame}

\subsection{Treaps}
\begin{frame}{Uma treap imersa no plano cartesiano.}
\boxblue{
\centering
Cada nó de uma treap possui um par ordenado \textbf{(chave, prioridade)}
}
\begin{figure}[htb]
\centering
\scalebox{.45}{
\input{fig/TREAP.tex}}
\end{figure}
\end{frame}

% --------------------------------------------------- %
%      Conexidade em grafos dinâmicos              %
% --------------------------------------------------- %
\section{Conexidade em grafos dinâmicos}
\subsection{Definição}
\begin{frame}{Conexidade em grafos dinâmicos}
\begin{exampleblock}{Conexidade em grafos dinâmicos}
\begin{itemize}
\item \dymGraphCreate($n$): cria um grafo dinâmico com $n$ vértices isolados;
\item \dymGraphAddEdge($G$, $u$, $v$): adiciona a aresta $uv$ ao grafo dinâmico $G$;
\item \dymGraphDelEdge($G$, $u$, $v$): remove a aresta $uv$ de $G$; e
\item \dymGraphQuery($G$, $u$, $v$): retorna verdadeiro se $u$ e $v$ estão na mesma componente conexa de $G$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}

\end{frame}

\begin{frame}{Ideia inicial}
\begin{block}{Manteremos}
\begin{itemize}
    \item floresta maximal dinâmica~$F$ de~$G$; e
    \item um grafo~$R$ = $G-F$
\end{itemize}
\end{block}

\begin{exampleblock}{Lista de adjacências}
\begin{itemize}
    \item \graphCreate($n$): devolve a representação por listas de adjacências de um grafo com~$n$ vértices isolados.
    \item \graphAdd($G$, $u$, $v$): adiciona $u$ na lista de adjacências de $v$ em $G$ e vice-versa.
    \item \graphDel($G$, $u$, $v$): remove $u$ da lista de adjacências de $v$ em $G$ e vice-versa.
\end{itemize}
\end{exampleblock}
\boxpurple{
\centering
~~~~~~\graphCreate{} : $\O{n}$\\
\graphAdd{}  : $\O{1}$\\
\graphDel{}  : $\O{1}$\\
}
\end{frame}


\begin{frame}{Ideia inicial}
\begin{algorithm}[H]
\caption{\dymGraphQuery($G$, $u$, $v$)}
\label{Algo:dymGraphQuery}
\begin{algorithmic}[1]
\State \Return \dymForestQuery($G$.$F$, $u$, $v$)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\dymGraphAddEdge($G$, $u$, $v$)}
\label{Algo:dymGraphAddEdge}
\begin{algorithmic}[1]
\If {\dymForestQuery($G.F$, $u$, $v$)}
\State \graphAdd($G$.$R$, $u$, $v$)
\Else 
\State \dymForestAddEdge($G.F$, $u$, $v$)
\EndIf
\end{algorithmic}
\end{algorithm}


\boxpurple{
\dymGraphQuery{} : $\O{\lg n}$\\
\dymGraphAddEdge{}  : $\O{\lg^2 n}$ amortizado\TODO{!!}
}
\end{frame}



\begin{frame}{Remoção de arestas}
\begin{block}{Estrutura de níveis}
\begin{itemize}
    \item Cada aresta possui um \defi{nível}, que é um inteiro entre~$1$ e $\lceil \log n \rceil$;
    \item Arestas serão inseridas no nível~$\lceil \log n \rceil$;
    \item O nível de uma aresta pode diminuir, mas nunca aumentar. 
\end{itemize}
\end{block}
\begin{block}{Estrutura}
$G_{\leqslant i}$: grafo com arestas de nível $\leqslant i$. Para cada camada $i$, manteremos:
\begin{itemize}
    \item $F_{\leqslant i}$: floresta maximal  de~$G_{\leqslant i}$; e
    \item $R_i$: arestas de nível~$i \notin F_{\leqslant i}$.
\end{itemize}
\end{block}
\begin{block}{Invariantes}
\begin{itemize}
    \item $F_{\leqslant i} \subseteq F_{\leqslant i+1}$, para cada $1\leqslant i \leqslant \lceil \log n \rceil-1$;
    \item $F_{\leqslant i}$ é uma floresta maximal de~$G_{\leqslant i}$; e
    \item Cada componente de $F_i$ possui menos do que $2^i$ arestas.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Implementações}
\begin{exampleblock}{Adaptações}
\centering
$G.F\rightarrow G.F_{\leqslant \lceil \log n \rceil}$\\
$G.R\rightarrow G.R_{\leqslant \lceil \log n \rceil}$
\end{exampleblock}
\begin{algorithm}[H]
\caption{\dymGraphDelEdge($G$, $u$, $v$)}
\label{Algo:dymGraphDelEdge}
\begin{algorithmic}[1]
\State $i$ $\gets$ \nivel[$u,v$]
\State \nivel[$u,v$] $\gets$ $\Nil$
\If {$uv$ $\in G.F_{\leqslant\lceil \lg n \rceil}$}\label{Algo:dymGraphDelEdge:linha:if}
\For {$j$ $\gets$ $i$ até $\lceil \lg n \rceil$}\label{linha2}
\State \dymForestDelEdge($G$.$F_j$, $u$, $v$)
\EndFor
\State \dymGraphReplace($G$, $u$, $v$, $i$)
\Else
  \State \graphDel($G$.$R_i$, $u$, $v$)\label{Algo:dymGraphDelEdge:linha:removeLA}
\EndIf
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
\dymGraphDelEdge{}  : $\O{\lg^2 n}$ amortizado.
}
\end{frame}

\begin{frame}{Estrutura de níveis}
\begin{figure}[htb]
\scalebox{.5}{
\input{fig/antes-rebaixar}
\input{fig/vazio}
\input{fig/depois-camada-alta}}
\end{figure}
\begin{figure}[htb]
\scalebox{.5}{
\input{fig/pontos}
\input{fig/vazio}
\input{fig/depois-camada-baixa}}
\end{figure}
\end{frame}




\begin{frame}{A rotina \dymGraphReplace{}}
\begin{algorithm}[H]
\caption{\dymGraphReplace($G$,$u$,$v$,$\nivel$)}
\label{Algo:dymGraphReplace}
\begin{algorithmic}[1]
\For {$i$ $\gets$ $niv$ até $\lceil \lg n \rceil$}\label{Algo:dymGraphReplace:linha:primeira}
\State $T_v$ $\gets$  \treapGetRoot($F_i[v,v]$)
\State $T_u$ $\gets$  \treapGetRoot($F_i[u,u]$)
\If {\treapGetSize($T_v$) < \treapGetSize($T_u$)}\Comment{Garantimos que $|T_v|\geqslant |T_u|$}
\State $u$ $\leftrightarrow$ $v$
\State $T_u \leftrightarrow T_v$
\EndIf
\For {$xy$ em $T_u$ com \nivel = $i$}\label{Algo:dymGraphReplace:linha:moveTu}\Comment{Move $T_u$ para o nível $i-1$}
\State \nivel$[x,y]$ $\gets$ $i-1$ \label{Algo:dymGraphReplace:linha:moveTu2}
\State \dymForestAddEdge($G$.$F_{i-1}$, $x$, $y$) \label{Algo:dymGraphReplace:linha:moveTu3}
\EndFor
\For {$xy$ em $G$.$R_i$ com $x$ em $T_u$}\label{Algo:dymGraphReplace:linha:achaSub}\Comment{Procura substituta para $uv$}
\State \graphDel($G$.$R_i$, $x$, $y$)
\If {$y \in T_v$}\label{Algo:dymGraphReplace:linhayinTv}
\For {$j \gets i$ até $\lceil \lg n \rceil$}\label{Algo:dymGraphReplace:linha:inseresub}
\State \dymForestAddEdge($G$.$F_j$, $x$, $y$)
\EndFor
\State \Return
\Else
\State \nivel$[x,y]$ $\gets$ $i-1$ \label{Algo:dymGraphReplace:linha:rebaixar}
\State \graphAdd($G$.$R_{i-1}$, $x$, $y$) \label{Algo:dymGraphReplace:linha:rebaixar2}
\EndIf
\EndFor
\EndFor\label{Algo:dymGraphReplace:linha:ultima}
\end{algorithmic}
\end{algorithm}
\end{frame}


% --------------------------------------------------------------------- %
% Floresta maximal de peso mínimo em grafos planos ponderados dinâmicos %
% --------------------------------------------------------------------- %
\section[MSF plano]{Floresta maximal de peso mínimo em grafos planos ponderados dinâmicos}

\subsection{Definição do problema}
\begin{frame}{Grafo plano}
\begin{block}{Grafo plano}
Um \defi{grafo plano}~\cite{Diestel} é um par de conjuntos finitos $G = (V, E)$ com as seguintes propriedades:
\begin{enumerate}
\item $V\subset \R^2$;
\item Toda aresta é um arco entre dois vértices;
\item O interior de uma aresta não contém vértices nem intersecta outras arestas.
\end{enumerate}
\end{block}
\begin{minipage}[H]{0.4\textwidth}
\begin{tabular}{| c  c |} 
 \hline
 aresta & peso\\
 \hline
 $a$ & 2 \\ 
 \hline
$b$ & 7 \\
 \hline
$c$ & 3 \\
 \hline
$d$ & 1 \\
 \hline
$f$ & 2 \\
 \hline
$g$ & 4 \\
 \hline
\end{tabular}
\end{minipage}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[H]
\scalebox{1}{
\input{fig/MSF-basico-0.tex}
	}
\end{figure}
\end{minipage}

\end{frame}




\begin{frame}{Grafo dual}
\begin{block}{Grafo dual}
Dado um grafo plano~$G$, o grafo \defi{dual} de~$G$~\cite{Diestel} é o grafo $G^\star = (F,E^\star)$, onde
\begin{itemize}
\item $F$ é o conjunto de faces de~$G$;
\item $E^\star$ é o conjunto de arestas duais de~$G$.
\end{itemize}
\end{block}
\begin{figure}[H]
\scalebox{1.2}{
\centering
\input{fig/MSF-basico-1.tex}
}
\label{fig:MSF-basico-1}
\end{figure}
\end{frame}

\begin{frame}{Descrição combinatória plana}
\begin{block}{descrição combinatória plana}
Para cada vértice $v$ de um grafo plano~$G$, existe uma ordem cíclica~$D(v)$ das aresta incidentes a~$v$ obtida percorrendo as arestas incidentes a~$v$ em sentido anti-horário até retornar à aresta inicial do percurso.
Uma \defi{descrição combinatória plana} de~$G$ é uma lista de todas essas ordens cíclicas.
\end{block}
\begin{minipage}[H]{0.1\textwidth}
\begin{align*}
D(u)&=\langle (a,v), (b,v), (c,z))\rangle\\
D(v)&=\langle (a,u), (d,z), (b,u)  \rangle\\
D(z)&=\langle (c,u), (d,v), (g,y) \rangle \\
D(y)&=\langle (e,z), (f,y), (f,y) \rangle
\end{align*}
\begin{align*}
D(F_0)&=\langle (a^\star, F_2), (c^\star, F_1), \\
      &~~~~~~~(g^\star, F_0), (y^\star, F_3), \\
      &~~~~~~~(g^\star, F_0), (d^\star, F_1) )\rangle\\
D(F_1)&=\langle (b^\star, F_2), (d^\star, F_0), (c^\star, F_0)  \rangle\\
D(F_2)&=\langle (a^\star, F_0), (b^\star, F_1)\rangle \\
D(F_3)&=\langle (f^\star, F_0)\rangle
\end{align*}
\end{minipage}
\hspace{-1cm}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[H]
\scalebox{1.2}{
\centering
\input{fig/MSF-basico-1.tex}
}
\label{fig:MSF-basico-1}
\end{figure}
\end{minipage}
\end{frame}

\begin{frame}{Floresta maximal de peso mínimo}
\begin{exampleblock}{O problema da floresta maximal de peso mínimo em grafos planos}
\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$): Insere em~$G$ uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. A nova aresta~$e$ é sucessora das arestas~$e_u$ e~$e_v$ nas ordenações cíclicas de~$u$ e~$v$, respectivamente.
\item \MSFdelEdge($G$, $e$): Remove a aresta~$e$ de~$G$.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ de~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}
\end{exampleblock}

\begin{exampleblock}{Árvores dinâmicas planas}
Apresentaremos a solução proposta por Eppstein e outros~\cite{EPPSTEIN-planar} para esse problema. 
O nome da estrutura de dados introduzida por esses autores é \textit{edge-ordered dynamic tree} que traduzimos para \defi{árvores dinâmicas planas}.
\end{exampleblock}

\end{frame}

\begin{frame}{Grafo dual}
\begin{theorem}[\cite{EPPSTEIN-planar}]
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo em~$G$ se e somente se~$T^\star$ for de peso máximo em~$G^\star$ e vice versa.
\end{theorem}

\begin{figure}[H]
\scalebox{.6}{
\input{fig/MSF-basico-1.tex}
}
\scalebox{1}{
\input{fig/MSF-basico-2}
}
\end{figure}
\end{frame}



\begin{frame}{Árvores modificadas}
\begin{minipage}[H]{0.3\textwidth}
\centering
\begin{tabular}{| c  c |} 
 \hline
 vértices & pesos\\
 \hline
 $\hat a$, $\hat a_1$, $\hat a_3$ & 2 \\ 
 \hline
 $\hat b$, $\hat b_0$, $\hat b_2$ & 7 \\
 \hline
 $\hat c$, $\hat c_0$, $\hat c_2$ & 3 \\
 \hline
 $\hat d$, $\hat d_0$, $\hat d_2$ & 2 \\
 \hline
 $\hat f$, $\hat f_1$, $\hat f_3$ & 1 \\
 \hline
 $\hat g$, $\hat g_1$, $\hat g_3$ & 4 \\
 \hline
 $\hat u$, $\hat v$, $\hat y$, $\hat z$ & $-\infty$ \\
 \hline
 $\hat F_0$, $\hat F_1$, $\hat F_2$, $\hat F_3$ & $\infty$ \\
 \hline
\end{tabular}
\end{minipage}
\begin{minipage}[H]{0.5\textwidth}
    \centering
\scalebox{.7}{
\input{fig/MSF-basico-3}
}
\end{minipage}
\end{frame}

\begin{frame}{Exemplo de ADP}
\begin{figure}[htb]
\scalebox{.9}{
\centering
\input{fig/MSF-basico-4}
}
\label{fig:MSF-figura-4}
\end{figure}
\begin{block}{Óctupla de $e$}
Há $8$ nós de link cut tree para cada aresta $e$ de~$G$.
Chamaremos esses~$8$ de \defi{óctupla de $e$}.
\end{block}
\end{frame}

\subsection{Árvores dinâmicas planas}
\begin{frame}{Árvores Dinâmicas Planas}
\begin{exampleblock}{Biblioteca ADP}
\begin{itemize}
\item \LCOMakeOcto($e$, $w$): Recebe um identificador~$e$ e um peso~$w$ e cria e retorna uma óctupla de nós de ADP associados a~$e$ com peso~$w$.
\item \LCODestroyOcto($H$, $e$): Recebe uma tabela de símbolos~$H$ e um identificador~$e$ e desaloca a óctupla associada a~$e$ da memória.

\item \LCOConnected($p$, $q$): Retorna verdadeiro se os nós~$p$ e~$q$ estiverem na mesma ADP e falso caso contrário.
\item \LCOFindNode($p$): Recebe um nó $p$ e retorna o vértice da~$\hat F$ que contêm $p$ em sua ordem cíclica.

\item \LCOAddCost($p$, $w$): Atribui o peso~$w$ ao vértice que contém $p$ em sua ordem cíclica.
\item \LCOMax($p$, $q$): Retorna o nó de peso máximo no percurso entre os nós~$p$ e~$q$.
Essa operação assume que $p$ e~$q$ são nós da mesma ADP.
\item \LCOMin($p$, $q$): Retorna o nó de peso mínimo no percurso entre os nós~$p$ e~$q$.
Essa operação assume que~$p$ e~$q$ são nós da mesma ADP.
\item \LCOCycle($p$): Permuta ciclicamente $D(u)$ de forma que o nó~$p$ seja o último na ordem.
Se a ordem inicial tem forma $\alpha p \beta$, então a ordem resultante é $\beta\alpha p$.
\item \treapPredecessor($p$): Retorna o predecessor do nó~$p$ na ordem cíclica.
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Resolvendo MSF com ADPs}
\begin{frame}{Criação de grafo plano ponderado dinâmico e obtenção de peso}
\begin{algorithm}[H]
\caption{\MSFCreate($n$)}
\label{Algo:MSFCreate}
\begin{algorithmic}[1]
\State $G.H$ $\gets$ \hashCreate($n$)
\State $G.p$ $\gets$ $0$
\State \Return $G$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\MSFweight($G$)}
\label{Algo:MSFweight}
\begin{algorithmic}[1]
\State \Return $G$.$p$
\end{algorithmic}
\end{algorithm}
\boxpurple{
	\centering
	\MSFCreate:~$\O{n}$.\\
	\MSFweight:~$\O{1}$.\\
	\MSFaddEdge:~$\O{\lg m}$\\
	\MSFdelEdge:~$\O{\lg m}$.\\
	\MSFupdate:~$\O{\lg m}$.
}
\end{frame}

\begin{frame}{Mudança de peso}
\begin{algorithm}[H]
\caption{\MSFupdate($G$, $e$, $w$)}
\label{Algo:MSFupdate}
\begin{algorithmic}[1]
	\State $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $G.H(e)$ \label{Algo:MSFupdate:linha:const1}
\For {$i \in \{0,1,2,3\}$} \label{Algo:MSFupdate:linha:laçosetpeso}
\State  \LCOAddCost($e_i$, $w$) \label{Algo:MSFupdate:linha:LCOAddCost}
\EndFor

\If {\LCOFindNode($e_0$) $=$ \LCOFindNode($e_2$)}\label{Algo:MSFupdate:linha:if} \Comment{$e\in F$}
\State $d$ $\gets$ \LCOMin($e_1$, $e_3$)\label{Algo:MSFupdate:linhamin}

\State $d_0$, $d_1$, $d_2$, $d_3$, $y_0$, $y_1$, $y_2$, $y_3$ $\gets$ $G.H(d)$ \label{Algo:MSFupdate:linha:const2}
\If {$d_0$.$w$ < $w$}\label{Algo:MSFupdate:linha:compara}
\State $G$.$p$ $\gets$ $G.p-e_0.w+d_0$.$w$ \label{Algo:MSFupdate:linha:atualizaPeso}
\State \LCOCycle($d_3$); \LCOSplit($d_3$, $\hat d_1$, $\hat d_3$)
\State \LCOCycle($e_2$); \LCOSplit($e_2$, $\hat e_0$, $\hat e_2$ )\label{Algo:MSFupdate:linhasplit}

\State \LCOMerge($d_0$, $d_2$, $\hat d$); \LCOMerge($e_1$, $e_3$, $\hat e$)\label{Algo:MSFupdate:linhas:Merge}

\EndIf

\Else\Comment{$e^\star\in F^\star$}
\State $d$ $\gets$ \LCOMax($e_0$, $e_2$)\label{Algo:MSFupdate:dualinicio}

\State $d_0$, $d_1$, $d_2$, $d_3$, $y_0$, $y_1$, $y_2$, $y_3$ $\gets$ $G.H(d)$\label{Algo:MSFupdate:linha:const3}
\If {$d_0$.$w$ > $w$}
\State $G$.$p$ $\gets$ $G$.$p-e_0.w+d_0$.$w$\label{Algo:MSFupdate:linha:const4}
\State \LCOCycle($d_0$); \LCOSplit($d_0$, $\hat d_2$, $\hat d_0$)
\State \LCOCycle($e_1$); \LCOSplit($e_1$, $\hat e_3$, $\hat e_1$)

\State \LCOMerge($d_1$, $d_3$, $\hat d$); \LCOMerge($e_0$, $e_2$, $\hat e$)

\EndIf
\EndIf\label{Algo:MSFupdate:dualfim}
\end{algorithmic}
\end{algorithm}
\end{frame}

\begin{frame}{Remoção de aresta}
\begin{algorithm}[H]
\caption{\MSFdelEdge($G$, $e$)}
\label{Algo:MSFdelEdge}
\begin{algorithmic}[1]
\State $e_0$, $e_1$, $e_2$, $e_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $G.H(e)$ \label{Algo:MSFdelEdge:linha:1}
\For {$i\in \{0, 1, 2, 3\}$}\label{Algo:MSFdelEdge:linha:laco}
\State $\hat e_i$ $\gets$ \LCOFindNode($e_i$)
\State $\hat v_i$ $\gets$ \LCOFindNode($v_i$)
\EndFor

\If {$\hat v_1$ $=$ $\hat v_3$ }\label{Algo:MSFdelEdge:linha2}\Comment{$e^\star$ é um laço de $G^\star$}

\State \LCOCycle($v_0$); \LCOSplit($v_0$, $\hat v_0$, \Nil)\label{Algo:MSFdelEdge:linha3}
\State \LCOCycle($v_1$); \LCOSplit($v_1$, $\hat v_1$, \Nil)\label{Algo:MSFdelEdge:c1:v1}
\State \LCOCycle($v_2$); \LCOSplit($v_2$, $\hat v_2$, \Nil)\label{Algo:MSFdelEdge:c1:v2}
\State \LCOSplit($v_3$, $F_0$, $F_1$) \label{Algo:MSFdelEdge:c1:split}
\State \LCOCycle($v_3$); \LCOSplit($v_3$, $\hat v_3$, \Nil)\label{Algo:MSFdelEdge:linha12}
\Else\Comment{$e$ está em um ciclo em $G$}
\State \MSFupdate($G$, $e$, $\infty$)\label{Algo:MSFdelEdge:linha:mudaPeso}
\State \LCOCycle($e_1$); \LCOSplit($e_1$, $\hat e_3$, $\hat e_1$) \label{Algo:MSFdelEdge:linha:split}
\State \LCOCycle($v_1$); \LCOCycle($v_3$); \LCOMerge($v_1$, $v_3$, $F_0$) \label{Algo:MSFdelEdge:linha:merge}
\State \LCOCycle($v_0$); \LCOSplit($v_0$, $\hat v_0$, \Nil) \label{Algo:MSFdelEdge:linha:1cs}
\State \LCOCycle($v_1$); \LCOSplit($v_1$, $F_0$, \Nil )
\State \LCOCycle($v_2$); \LCOSplit($v_2$, $\hat v_2$, \Nil)
\State \LCOCycle($v_3$); \LCOSplit($v_3$, $F_0$, \Nil)
	\label{Algo:MSFdelEdge:linha:ucs}
	\label{Algo:MSFdelEdge:linha:fim}
\EndIf
\State \LCODestroyOcto($G.H$, $e$)\label{Algo:MSFdelEdge:linha:desaloca}
\end{algorithmic}
\end{algorithm}
\end{frame}

\begin{frame}{Adição de aresta}
\begin{algorithm}[H]
\caption{\MSFaddEdge($G$, $e$, $u$, $f$, $v$, $g$, $w$)}
\label{Algo:MSFaddEdge}
\begin{algorithmic}[1]

\State $f_0$, $f_1$, $f_2$, $f_3$, $u_0$, $u_1$, $u_2$, $u_3$ $\gets$ $G.H(f)$ \label{Algo:MSFaddEdge:linha:1}
\State $g_0$, $g_1$, $g_2$, $g_3$, $v_0$, $v_1$, $v_2$, $v_3$ $\gets$ $G.H(g)$ \label{Algo:MSFaddEdge:linha:2}

\If {\LCOFindNode($u_0$) $=$ $u$} $i$ $\gets$ $0$ \textbf{senão} $i$ $\gets$ $2$
\EndIf
\If {\LCOFindNode($v_0$) $=$ $v$} $j$ $\gets$ $0$ \textbf{senão} $j$ $\gets$ $2$
\EndIf


\State $G.H(e)$ $\gets$ $e_0$, $e_1$, $e_2$, $e_3$, $s_0$, $s_1$, $s_2$, $s_3$ $\gets$ \LCOMakeOcto($e$, $w$) \label{Algo:MSFaddEdge:linha:const3}

\State \LCOCycle($u_i$); \LCOMerge($u_i$, $s_0$, $u$)\label{Algo:MSFaddEdge:merges0}
\State \LCOCycle($v_j$); \LCOMerge($v_j$, $s_2$, $v$)\label{Algo:MSFaddEdge:merges2}


\State \LCOCycle(\treapPredecessor($u_{i-1}$)); \LCOMerge($u_{i-1}$, $s_3$, \LCOFindNode($u_{i-1}$))\label{Algo:MSFaddEdge:merges1}
\State \LCOCycle(\treapPredecessor($v_{j-1}$)); \LCOMerge($v_{j-1}$, $s_1$, \LCOFindNode($v_{j-1}$))\label{Algo:MSFaddEdge:merges3}

\If{\LCOConnected($u$, $v$)}\label{Algo:MSFaddEdge:linha:deteccao-caso}
\State \LCOSplit($u_{i-1}$, $F_u$, $F'_u$)\label{Algo:MSFaddEdge:linha:splitnaoponte}
\State \MSFupdate($G$, $e$, $w$)
\Else
\State \LCOMerge($u_{i+1}$, $v_{j+1}$, $F_{uv}$)\label{Algo:MSFaddEdge:linha:mergeponte}
\State \LCOMerge($e_0$, $e_2$, $\hat e$)
\EndIf
\end{algorithmic}
\end{algorithm}

\end{frame}

\iffalse
\begin{frame}{}
\end{frame}

\begin{frame}{}
\end{frame}
\fi
\subsection{Implementação de árvores dinâmicas planas}


\section{O limitante inferior de~$\Omega(\lg n)$}
\subsection{Verificação de soma parcial em~$S_k$}

\begin{frame}{Verificação de soma parcial em~$S_k$}
Mihai Patrascu e Erik D. Demaine~\cite{lowerBoundPatrascu} provaram o seguinte limitante inferior:
\begin{theorem}
Seja $t_m$ o consumo de tempo de \dymGraphAddEdge{} ou \dymGraphDelEdge{} e~$t_c$ o consumo de tempo de \dymGraphQuery{}, então
$$
\min\{ t_m, t_c\}\lg \left( \frac{\max\{ t_m, t_c\}}{\min\{ t_m,t_c\}}\right) = \Omega(\lg n).
$$
Esse limitante é válido mesmo para implementações aleatorizadas e/ou amortizadas de \dymGraphAddEdge{}, \dymGraphDelEdge{} e \dymGraphQuery{} e mesmo restringindo a classe de grafos do problema para caminhos.
\end{theorem}
\end{frame}

\begin{frame}{Ideia de prova}

\begin{enumerate}
\item Apresentar o problema VSP$S_k$.
\item Reduzir VSP$S_k$ a conexidade de grafos dinâmicos.
\item Usar um limitante inferior de VSP$S_k$ para limitar o problema de conexidade de grafos dinâmicos.
\end{enumerate}
\end{frame}

\begin{frame}{Verificação de soma parcial em~$S_k$}
O grupo $S_k$ é o grupo finito formado pelo conjunto de todas as bijeções sobre o conjunto~${[k]:=\{1,2,\ldots,k\}}$ munido da operação de composição de funções~\cite{agozine2010}.
\begin{figure}[htb]
\centering
\input{fig/LIM-exemplo-uma-perm}
\label{fig:LIM-exemplo-uma-perm}
\end{figure}
\end{frame}

\begin{frame}{Grafo dual}
\begin{figure}[htb]
\centering
	\scalebox{.8}{
\input{fig/LIM-exemplo-comp}
	}
\caption{Exemplo de uma composição de permutações adotando $p=4$. Temos~$\varphi = \phi_4\circ \phi_3\circ \phi_2\circ \phi_1$.}
\label{fig:LIM-exemplo-comp}
\end{figure}
\end{frame}

\begin{frame}{Problema da verificação de soma parcial em $S_{k}$}
\begin{exampleblock}{Problema da verificação de soma parcial em $S_{k}$}
O \defi{problema da verificação de soma parcial em $S_{k}$ (VSP$S_k$)} visa manter uma sequência de~$p$ permutações ${\phi=(\phi_1, \phi_2, \ldots, \phi_p)}$ de forma a implementar eficientemente a seguinte biblioteca:
\begin{itemize}
\item \VPSPupdate($\phi$, $i$, $\varphi$): a $i$-ésima coordenada de $\phi$ passa a ser a permutação~$\varphi$ ; e
\item \VPSPverify($\phi$, $i$, $\varphi$): retorna verdadeiro se~$\phi_i\circ \cdots\circ \phi_1 = \varphi$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}
\end{frame}

\begin{frame}{Limitante inferior para o problema VSP$S_k$}
Mihai Patrascu e Erik D. Demaine~\cite{lowerBoundPatrascu} provaram o seguinte resultado:

\begin{theorem}
Os consumos de tempo $t_u$ e $t_q$ das rotinas \VPSPupdate{} e~\VPSPverify, respectivamente, implementadas com qualquer estrutura de dados sob o modelo \textit{cell-probe} para solucionar VSP$S_k$ estão relacionados e limitados por
$$
\min\{t_u,t_q\}\lg \left( \frac{\max\{t_u,t_q\}}{\min\{t_u,t_q\}}\right) = \Omega\left(\frac{\delta}{b}\lg p\right),
$$
onde cada célula possui $b$ bits e são necessários $\delta$ bits para representar cada parâmetro da rotina.  Esse limitante continua válido mesmo se a estrutura de dados utilizar amortização, não determinismo, aleatorização Las Vegas ou Monte Carlo com erro probabilístico~$p^{-\Omega(1)}$.
\end{theorem}
\end{frame}

\subsection[Redução do VSP$S_k$ para conexidade em grafos dinâmicos]{Redução do problema VSP$S_k$ para conexidade em grafos dinâmicos}

\begin{frame}{Redução de VSP$S_k$ a conexidade de grafos dinâmicos}
\begin{figure}[htb]
\centering
\input{fig/LIM-convertido}
\label{fig:LIM-convertido}
\end{figure}
\end{frame}

\begin{frame}{Rotina para converter uma instância de VSP$S_k$ em uma intância de conexidade em grafos dinâmicos}
\begin{algorithm}[H]
\caption{\VPSPconvert($\phi$, $p$, $k$)}
\label{Algo:VPSPconvert}
\begin{algorithmic}[1]
\State $G(\phi)$ $\gets$ \dymGraphCreate($(p+1)\cdot k)$
\State $G(\phi).\phi$ $\gets$ $\phi$
\For {$x$ $\gets$ 1 até $p+1$}
  \For {$y$ $\gets$ 1 até $k$}
    \State \dymGraphAddEdge($G(\phi)$, $(x,~y)$, $(x+1, ~\phi_x(y))$)
  \EndFor
\EndFor
\State \Return $G(\phi)$
\end{algorithmic}
\end{algorithm}
\end{frame}

\begin{frame}{Grafo dual}
\begin{algorithm}[H]
\caption{\VPSPupdate($G(\phi)$, $i$, $\varphi$)}
\label{Algo:VPSPupdate}
\begin{algorithmic}[1]
\For {$y$ $\gets$ 1 até $k$}
  \State \dymGraphDelEdge($G(\phi)$, $(i,y)$, $(i+1,\phi_i(y)$))
\EndFor
\For {$y$ $\gets$ 1 até $k$}
  \State \dymGraphAddEdge($G(\phi)$, $(i,y)$, $(i+1,\varphi(y)$))
\EndFor
\State $G(\phi)$.$\phi_i$ $\gets$ $\varphi$ 
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\VPSPverify($G(\phi)$, $i$, $\varphi$)}
\label{Algo:VPSPverify}
\begin{algorithmic}[1]
\For {$y$ $\gets$ 1 até $k$}
  \If {\textbf{não} \dymGraphQuery($G(\phi)$, $(1,y)$, $(i+1,\varphi(y)$))}
    \State \Return falso
  \EndIf
\EndFor
\State \Return verdadeiro
\end{algorithmic}
\end{algorithm}
\end{frame}

\subsection{Limitante inferior para conexidade em grafos dinâmicos}
\begin{frame}{Grafo dual}
Adotando $\delta = \Theta(k\cdot b)$.
\begin{equation}
\Omega\left( \frac{\delta}{b}\lg p \right)\implies \Omega\left(\frac{k\cdot b}{b}\lg p\right)\implies \Omega(k\lg p).\label{eq:lim-kp}
\end{equation}
Especificamente, escolheremos a família em que~$k = p-1$.
Para essa escolha, temos
$$
n =k\cdot (p+1) =(p-1)\cdot  (p+1) =p^2-1.
$$
Dessa forma, teremos:
$$
\Omega(k \lg p) = \Omega(k\cdot  2\cdot \lg p) = \Omega(k \lg p^2) = \Omega(k \lg n).\nonumber 
$$
\end{frame}

\begin{frame}{Grafo dual}
Para concluirmos, note que $\Omega(k\lg n)$ limita inferiormente o consumo de tempo das rotinas \VPSPupdate{} e \VPSPverify{}. O algoritmo \VPSPupdate{} faz~$k$ remoções e inserções de arestas e \VPSPverify{} faz~$k$ consultas de conexidade. Logo se denotarmos por $t_m$ a soma do consumo de tempo de uma execução de \dymGraphAddEdge{} e \dymGraphDelEdge{} e $t_c$ o consumo de tempo de \dymGraphQuery{}, então deduzimos que $t_u = k t_m$ e $t_q = k t_c$. Substituindo esses valores no Teorema~\ref{theo:lim}, teremos:
\begin{align*}
\min\{t_u,t_q\}\lg \left( \frac{\max\{t_u,t_q\}}{\min\{t_u,t_q\}}\right) &= \Omega\left(\frac{\delta}{b}\lg p\right)&\implies\\
\min\{k t_m,k t_c\}\lg \left( \frac{\max\{k t_m,k t_c\}}{\min\{k t_m,k t_c\}}\right) &= \Omega(k \lg n)&\implies\\
k\min\{ t_m, t_c\}\lg \left( \frac{\max\{ t_m, t_c\}}{\min\{ t_m,t_c\}}\right) &= \Omega(k \lg n).
\end{align*}
Portanto obtemos o seguinte limitante amortizado: 
$$
\min\{ t_m, t_c\}\lg \left( \frac{\max\{ t_m, t_c\}}{\min\{ t_m,t_c\}}\right) = \Omega(\lg n)
$$
para cada uma das chamadas das operações de conexidade em grafos dinâmicos.
\end{frame}



\section{Bibliografia}
\begin{frame}[allowframebreaks]
\frametitle{Bibliografia}
\bibliographystyle{plain}
    \bibliography{bib.bib}
\end{frame}

\end{document}
