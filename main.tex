\documentclass{IFES-beamer}
\usepackage{pgfplots}
\pgfplotsset{compat=1.15}
\usepackage{amssymb}
\usepackage{graphicx,xcolor}
\usepackage{color}
\definecolor{ccqqqq}{rgb}{1,0,0}
\definecolor{darkGreen}{rgb}{0,.5,0}

\usepackage[brazilian]{babel}
\usepackage{amsthm}
\newtheorem*{teorema}{Teorema}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Defini o estlo no algorithmic
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\R}{\mathbb{R}}
\newcommand{\red}{\color{red}}
\newcommand{\green}{\color{green}}
\newcommand{\TODO}[1]{{{\red #1}}}
%\newcommand{\var}[1]{$#1$} %define estilo de nomes de variaveis
\newcommand{\defi}[1]{\textbf{#1}} % defini estilo ao definir algo no texto
\def\Nil{\text{NIL}}

\newcommand\circledmark{%
  \ooalign{%
    \hidewidth
    \kern-0.4ex\raisebox{-2.1ex}{\scalebox{5.5}{\textcolor{darkGreen}{\textbullet}}}
    \hidewidth\cr
    \kern-.6ex\raisebox{.6ex}{\color{white}$\checkmark$}\cr
  }%
}
\newcommand\custommark{%
  \ooalign{%
    \hidewidth
    \kern-0.4ex\raisebox{-2.1ex}{\scalebox{5.5}{\textcolor{white}{\textbullet}}}
    \hidewidth\cr
    \kern-.6ex{\color{black}$\checkmark$}\cr
  }%
}


\usepackage[Algoritmo]{algorithm}
\usepackage[noend]{algpseudocode}
\algrenewcommand\algorithmicif{\textbf{se}}
\algrenewcommand\algorithmicfor{\textbf{para}}
\algrenewcommand\algorithmicelse{\textbf{senão}}
\algrenewcommand\algorithmicwhile{\textbf{enquanto}}
\algrenewcommand\algorithmicdo{\textbf{faça}}
\algrenewcommand\algorithmicend{\textbf{fim}}
\algrenewcommand\algorithmicthen{\textbf{então}}
\algrenewcommand\algorithmicreturn{\textbf{retorne}}



\newcommand{\AlgoName}[1]{\text{\scshape #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Comandos de notação assintotica   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\O}[1]{\text{O}(#1)}
\newcommand{\OTheta}[1]{\Theta(#1)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    Nomes de váriaveis      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\varname}[1]{\textit{#1}}
\newcommand{\altvarname}[1]{$#1$}
\newcommand{\node}{\textit{nó}}
\newcommand{\var}{\mathit{var}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de Grafos      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\graphCreate}{\AlgoName{novoGrafo}}
\newcommand{\graphAdd}{\AlgoName{ligueGLA}}
\newcommand{\graphDel}{\AlgoName{removaGLA}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de Treap       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\treapCreate}{\AlgoName{novoNó}}
\newcommand{\treapSearch}{\AlgoName{busca}}
\newcommand{\treapGetLast}{\AlgoName{último}}
\newcommand{\treapGetRoot}{\AlgoName{raiz}}
\newcommand{\treapOrder}{\AlgoName{ordem}}
\newcommand{\treapJoin}{\AlgoName{junta}}
\newcommand{\treapSplit}{\AlgoName{corta}}
\newcommand{\treapSplitRight}{\AlgoName{cortaDireita}}
\newcommand{\treapGetSize}{\AlgoName{tamanho}}
\newcommand{\treapGetEdgesLevel}{\AlgoName{arestasDeNível}}

\newcommand{\treapFirst}{\AlgoName{primeiro}}
\newcommand{\treapLast}{\AlgoName{último}}
\newcommand{\treapPredecessor}{\AlgoName{\AlgoName{Pred}}}    %(F, u, v)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Euler Tour Tree %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ETTCreate}{\AlgoName{novoETT}}     % (v)
\newcommand{\ETTAddEdge}{\AlgoName{ligueETT}} % ($F$, $uu$, $vv$)
\newcommand{\ETTDelEdge}{\AlgoName{removaETT}} % ($F$, $uu$, $vv$)
\newcommand{\ETTQuery}{\AlgoName{conectadoETT}} % ($F$, $uu$, $vv$)
\newcommand{\ETmovetofront}{\AlgoName{movaInício}} % ($F$, $uu$)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos da tabela hash         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\dymForestHash}{$H$}  %simbolo que identifica a matriz/hash da floresta
\newcommand{\nivel}{\AlgoName{nível}} 
\newcommand{\hashCreate}{\AlgoName{novoDicio}}     

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Florestas dinamicas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\dymForestCreate}{\AlgoName{novaFD}}  %(n)
\newcommand{\dymForestAddEdge}{\AlgoName{ligueFD}}    %(F, u, v)
\newcommand{\dymForestDelEdge}{\AlgoName{removaFD}}    %(F, u, v)
\newcommand{\dymForestQuery}{\AlgoName{\AlgoName{conectadoFD}}}    %(F, u, v)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Grafos dinamicas %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\dymGraphCreate}{\AlgoName{novoGD}}    %(n)
\newcommand{\dymGraphAddEdge}{\AlgoName{ligueGD}} %(G, u, v)
\newcommand{\dymGraphDelEdge}{\AlgoName{removaGD}} %(G, u, v)
\newcommand{\dymGraphQuery}{\AlgoName{\AlgoName{conectadoGD}}} %(G, u, v)
\newcommand{\dymGraphReplace}{\AlgoName{\AlgoName{substituaGD}}} %(G, u, v, i)
\newcommand{\dymGraphHash}{$H$}  %simbolo que identifica a matriz/hash da floresta

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Link/Cut Tree   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\linkcutCreate}{\AlgoName{newLCT}}
\newcommand{\linkcutDestroy}{\AlgoName{delLCT}}
\newcommand{\linkcutAddEdge}{\AlgoName{link}}    %(F, u, v)
\newcommand{\linkcutDelEdge}{\AlgoName{cut}}    %(F, u, v)
\newcommand{\linkcutEvert}{\AlgoName{\AlgoName{evert}}}    %(v)
\newcommand{\linkcutMax}{\AlgoName{\AlgoName{max}}}    %(F, u, v)
\newcommand{\linkcutMin}{\AlgoName{\AlgoName{min}}}    %(F, u, v)
\newcommand{\linkcutParent}{\AlgoName{\AlgoName{parent}}}    %(F, u, v)
\newcommand{\linkcutQuery}{\AlgoName{\AlgoName{conectadoLC}}}    %(F, u, v)
\newcommand{\linkcutWeight}{\AlgoName{\AlgoName{set weight}}}    %(F, u, v)
\newcommand{\linkcutRoot}{\AlgoName{\AlgoName{get Root}}}    %(F, u, v)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Métodos de Link/Cut Tree com ordem  %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\LCOMakeOcto}{\AlgoName{Create Octo}}
\newcommand{\LCODestroyOcto}{\AlgoName{Destroy Octo}}

\newcommand{\LCOMakeNode}{\AlgoName{Make edge}}
\newcommand{\LCODestroyNode}{\AlgoName{Make edge}}
\newcommand{\LCOLink}{\AlgoName{Link}}
\newcommand{\LCOMerge}{\AlgoName{Merge}}
\newcommand{\LCOSplit}{\AlgoName{Split}}
\newcommand{\LCOCycle}{\AlgoName{Cycle}}
\newcommand{\LCOParent}{\AlgoName{\AlgoName{Parent}}}    %(F, u, v)
\newcommand{\LCORoot}{\AlgoName{Root}}
\newcommand{\LCOAddCost}{\AlgoName{Set weight}}
\newcommand{\LCOMax}{\AlgoName{\AlgoName{Find max}}}    %(F, u, v)
\newcommand{\LCOMin}{\AlgoName{\AlgoName{Find min}}}    %(F, u, v)
\newcommand{\LCOEvert}{\AlgoName{\AlgoName{Evert}}}    %(F, u, v)
\newcommand{\LCOConnected}{\AlgoName{\AlgoName{Connected}}}    %(F, u, v)
\newcommand{\LCOFindNode}{\AlgoName{Find node}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de MSF         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\MSFCreate}{\AlgoName{novoGDP}} %(n)
\newcommand{\MSFupdate}{\AlgoName{mudaPesoGDP}} %(n)
\newcommand{\MSFaddEdge}{\AlgoName{ligueGDP}}    %(G, u, v, w)
\newcommand{\MSFdelEdge}{\AlgoName{removaGDP}}    %(G, u, v)
\newcommand{\MSFweight}{\AlgoName{pesoGDP}}    %(G)

\newcommand{\dymGraphReplaceMSF}{\AlgoName{substituaGDP}} %(G, u, v, i)
\newcommand{\treapGetEdgeMinWeight}{\AlgoName{arestaMinPesoGDP}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     Métodos de VPSP
% Verify partial sum of permutations%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\VPSPconvert}{\AlgoName{converta}}
\newcommand{\VPSPupdate}{\AlgoName{substitua}}
\newcommand{\VPSPverify}{\AlgoName{verifique}}




% --------------------------------------------------- %
%                  Presentation info	              %
% --------------------------------------------------- %
\title[Algorit. em conexidade dinâmica]{Algoritmos para conexidade em grafos dinâmicos}
%\subtitle{Subtitle}
\author[Arthur Rodrigues]{Arthur Henrique Dias Rodrigues\\{\footnotesize sob orientação de}\\Cristina Gomes Fernandes}
\institute[IME-USP]{
  Instituto de Matemática e Estatística\\
  USP
}
\day=22
\month=11
\year=2024
\subject{Algorit. em conexidade dinâmica} % metadata

% --------------------------------------------------- %
%                    Title + Schedule                 %
% --------------------------------------------------- %


\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Sumário}
  \tableofcontents
\end{frame}

\iffalse
% --------------------------------------------------- %
%                      Presentation                   %
% --------------------------------------------------- %

\section{Problemas}
\subsection{Definições}
\begin{frame}{Problema de conexidade dinâmicas}
\begin{block}{Contexto}
\begin{itemize}
    \item $G$: grafo;
    \item $n$: número de vértices em~$G$;
    \item $F$: floresta;
    \item $u$,$v$: vértices.
    \end{itemize}
\end{block}

\begin{exampleblock}{Problema de conexidade dinâmicas}
\begin{itemize}
\item \dymGraphCreate($n$): retorna um grafo dinâmico com $n$ vértices isolados;
\item \dymGraphAddEdge($G$, $u$, $v$): adiciona aresta $uv$ a~$G$;
\item \dymGraphDelEdge($G$, $u$, $v$): remove $uv$ de $G$; e
\item \dymGraphQuery($G$, $u$, $v$): retorna verdadeiro se $u$ e~$v$ estão na mesma componente conexa de~$G$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}

\end{frame}

\begin{frame}{Problemas MSF}
\boxblue{MSF: floresta maximal de peso mínimo}
\begin{block}{Grafo ponderado}
Cada aresta possui um peso associado.
\end{block}

\begin{exampleblock}{Problema de floresta maximal de peso mínimo em grafos ponderados planos dinâmicos}
\begin{itemize}
\item \MSFCreate($n$): devolve um grafo ponderado com $n$ vértices isolados;
\item \MSFaddEdge($G$, $u$, $v$, $w$): adiciona a aresta~$uv$ com peso~$w$ em~$G$;
\item \MSFdelEdge($G$, $u$, $v$): remove a aresta $uv$ de $G$; e
\item \MSFweight($G$): devolve o peso de uma MSF de $G$.
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Resultados conhecidos}
\begin{frame}{Resultados conhecidos}
\begin{alertblock}{Limitante inferior (Patrascu e Demaine)~\cite{lowerBoundPatrascu}, 2006}
Todo algoritmo que resolve os problemas de conexidade dinâmica e de MSF dinâmica possuem consumo de tempo~$\Omega(\lg n)$.
\end{alertblock}
\begin{block}{Conexidade dinâmicas~(Holm et al.~\cite{poly_log}, 2001)}
Para árvores,~$\O{\lg n}$;\\
Grafos gerais,~$\O{\lg^2 n}$ amortizado.
\end{block}

\begin{block}{MSF~(Holm et al.~\cite{poly_log}, 2001)}
Para grafos gerais, amortizado~$\O{\lg^4 n}$.
\end{block}
\end{frame}
\fi

% --------------------------------------------------- %
%      Conexidade em florestas dinâmicas              %
% --------------------------------------------------- %
\section{Conexidade em florestas dinâmicas}
\subsection{Definição}
\begin{frame}{Conexidade em florestas dinâmicas}

\begin{exampleblock}{Problema de conexidade em florestas dinâmicas}
\begin{itemize}
\item \dymForestCreate($n$): retorna uma floresta dinâmica com $n$ vértices isolados;
\item \dymForestAddEdge($F$,$u$,$v$): adiciona $uv$ a~$F$;
\item \dymForestDelEdge($F$,$u$,$v$): remove $uv$ de $F$; e
\item \dymForestQuery($F$,$u$,$v$): retorna verdadeiro se $u$ e~$v$ estão na mesma componente conexa de~$F$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}
Para solucionar esse problema, vamos apresentar a estrutura de dados proposta por Henzinger e King.
\end{frame}

\subsection{Euler Tour Trees}

\begin{frame}{Sequência Euleriana}
\begin{figure}[htb]
\centering
\scalebox{.9}{
\input{fig/exemploSeqEuler.tex}
\input{fig/exemploSeqEulerTransformada.tex}
	}
\end{figure}
\begin{center}
{\large 30~00~04~41~12~22~21~11~14~44~45~55~54~40~03~33}
\end{center}
\end{frame}

\begin{frame}{Euler Tour Trees}
\begin{figure}[htb]
\centering
\scalebox{.7}{
\input{fig/SEQ-INDICES.tex}}
\end{figure}
\begin{tabular}{| c p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} |} 
 \hline
	arco &30&00&04&41&12&22&21&11&14&44&45&55&54&40&03&33\\
 \hline
	índice &1&2&3&4&5&6&7&8&9&10&11&12&13&14&15&16 \\ 
 \hline
\end{tabular}
\end{frame}



\begin{frame}{Chaves implícitas}
\begin{figure}[htb]
\scalebox{.7}{
\centering
\input{fig/SEQ-SIZE.tex}}
\end{figure}
\begin{tabular}{| c p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} p{0.13cm} |} 
 \hline
	arco &30&00&04&41&12&22&21&11&14&44&45&55&54&40&03&33\\
 \hline
	índice &1&2&3&4&5&6&7&8&9&10&11&12&13&14&15&16 \\ 
 \hline
\end{tabular}
\end{frame}


\begin{frame}{Biblioteca de Euler Tour Trees}
\begin{exampleblock}{Biblioteca de Euler Tour Trees}
\begin{itemize}
\item  \treapCreate($u$, $v$): retorna uma ABB com um único nó com valor uv;
\item \treapJoin($T$, $R$): junta as ABBs $T$ e $R$ concatenando as sequências Eulerianas armazenada nelas e retorna a raiz da árvore resultante.
\item \treapSplit($\node$): corta a ABB que contém um nó~$\node$ em três ABBs. A primeira ABB contém todos os nós com chave estritamente menor do que a chave de~$\node$, a segunda contém somente~$\node$ e a última contém todos os nós com chave estritamente maior do que a chave de~$\node$. Essa rotina retorna as raízes dessas três ABBs; e
\item \treapGetRoot($\node$): retorna a raiz da ABB que contém $\node$;
\end{itemize}
\end{exampleblock}
\boxpurple{\centering  \treapCreate{}:~$\O{1}$.\\ As demais operações :~$\O{\lg n}$.}
\end{frame}

\begin{frame}{Tabela de símbolos}
\boxblue{
\centering
Associa $(u,v) \rightarrow uv$.
}
\begin{exampleblock}{Biblioteca de tabela de símbolos}
\begin{itemize}
    \item $F \gets \hashCreate(n)$: cria e retorna um dicionário~$F$ para uma floresta dinâmica com~$n$ vértices;
    \item $F[u,v] \gets uv$: insere o nó que contém $uv$, com chave $(u,v)$ e valor associado~$uv$ na tabela~$F$.
    Se o par~$(u,v)$ já estiver presente no dicionário, então seu valor associado é substituído por~$uv$;
    \item $F[u,v] \gets \Nil{}$: remove o nó associado a~$(u,v)$ e seu valor associado do dicionário~$F$;
    \item $\var{} \gets F[u,v]$: atribui o valor associado à chave~$(u,v)$ à variável~$\var$;
	Caso a chave~$(u,v)$ não esteja presente em~$F$, atribui~$\Nil$ a~$\var{} $.
\end{itemize}
\end{exampleblock}
\boxpurple{
\centering
Consumo esperado~$\O{1}$ por rotina~\cite{CLRS}.
}
\end{frame}

\begin{frame}{Implementação da interface de floresta dinâmica}
\begin{algorithm}[H]
\caption{\dymForestCreate($n$)}
\label{Algo:dymForestCreate}
\begin{algorithmic}[1]
\State $F~\gets~\hashCreate(n)$
\For {$v$ $\gets$ 1 até $n$}\label{Algo:dymForestCreate:for}
\State $F[v,v]~\gets$ \treapCreate($v$, $v$)
\EndFor
\State \Return $F$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\dymForestQuery($F$, $u$, $v$)}
\label{Algo:dymForestQuery}
\begin{algorithmic}[1]
\State \varname{uu} $\gets$ $F[u,u]$
\State $vv$ $\gets$ $F[v,v]$
\State \Return \treapGetRoot(\varname{uu}) = \treapGetRoot($vv$)
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
~~~~~\dymForestCreate{} : $\O{n}$\\
\dymForestQuery{}  : $\O{\lg n}$
}
\end{frame}

\begin{frame}{Implementação da interface de floresta dinâmica}
\begin{algorithm}[H]
\caption{\ETmovetofront($F$,$u$)}
\label{Algo:ETmovetofront}
\begin{algorithmic}[1]
\State \varname{uu} $\gets$ $F[u,u]$\label{Algo:ETmovetofront:1}
\State $A$, \varname{uu}, $B$ $\gets$ \treapSplit(\varname{uu})\label{Algo:ETmovetofront:2}
\State \Return \treapJoin(\varname{uu}, $B$, $A$)\label{Algo:ETmovetofront:3}
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\dymForestAddEdge($F$,$u$,$v$)}
\label{Algo:dymForestAddEdge}
\begin{algorithmic}[1]
\State $U$ $\gets$ \ETmovetofront($F$, $u$)
\State $V$ $\gets$ \ETmovetofront($F$, $v$)
\State $uv$ $\gets$ \treapCreate($u$, $v$)
\State $vu$ $\gets$ \treapCreate($v$, $u$)
\State $F[u,v]$ $\gets$ $uv$
\State $F[v,u]$ $\gets$ $vu$
\State \treapJoin($U$, $uv$, $V$, $vu$)
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
\dymForestAddEdge{}  : $\O{\lg n}$\\
\ETmovetofront{}  : $\O{\lg n}$
}
\end{frame}

\begin{frame}{Implementação da interface de floresta dinâmica}
\begin{algorithm}[H]
\caption{\dymForestDelEdge($F$, $u$, $v$)}
\label{Algo:dymForestDelEdge}
\begin{algorithmic}[1]
\State $uv$ $\gets$ $F[u,v]$\label{Algo:dymForestDelEdge:1}
\State $vu$ $\gets$ $F[v,u]$\label{Algo:dymForestDelEdge:2}
\State $A$, $uv$, $B$ $\gets$ \treapSplit($uv$)\label{Algo:dymForestDelEdge:3}
\State \treapJoin($B$, $A$)\label{Algo:dymForestDelEdge:4}
\State \treapSplit($vu$)\label{Algo:dymForestDelEdge:5}
\State $F[u,v]$ $\gets$ $\Nil{}$\label{Algo:dymForestDelEdge:6}
\State $F[v,u]$ $\gets$ $\Nil{}$\label{Algo:dymForestDelEdge:7}
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
\dymForestDelEdge{}  : $\O{\lg n}$
}
\end{frame}


% --------------------------------------------------- %
%      Conexidade em grafos dinâmicos              %
% --------------------------------------------------- %
\section{Conexidade em grafos dinâmicos}
\subsection{Definição}
\begin{frame}{Conexidade em grafos dinâmicos}
\begin{exampleblock}{Conexidade em grafos dinâmicos}
\begin{itemize}
\item \dymGraphCreate($n$): cria um grafo dinâmico com $n$ vértices isolados;
\item \dymGraphAddEdge($G$, $u$, $v$): adiciona a aresta $uv$ ao grafo dinâmico $G$;
\item \dymGraphDelEdge($G$, $u$, $v$): remove a aresta $uv$ de $G$; e
\item \dymGraphQuery($G$, $u$, $v$): retorna verdadeiro se $u$ e $v$ estão na mesma componente conexa de $G$ e falso, caso contrário.
\end{itemize}
\end{exampleblock}
Para solucionar esse problema, vamos apresentar a estrutura de dados proposta por Holm, de Lichtenberg e Thorup.

\end{frame}

\begin{frame}{Ideia inicial}
\begin{block}{Manteremos}
\begin{itemize}
    \item floresta maximal dinâmica~$F$ de~$G$; e
    \item um grafo~$R$ = $G-F$
\end{itemize}
\end{block}

\begin{exampleblock}{Lista de adjacências}
\begin{itemize}
    \item \graphCreate($n$): devolve a representação por listas de adjacências de um grafo com~$n$ vértices isolados.
    \item \graphAdd($G$, $u$, $v$): adiciona $u$ na lista de adjacências de $v$ em $G$ e vice-versa.
    \item \graphDel($G$, $u$, $v$): remove $u$ da lista de adjacências de $v$ em $G$ e vice-versa.
\end{itemize}
\end{exampleblock}
\boxpurple{
\centering
~~~~~~\graphCreate{} : $\O{n}$\\
\graphAdd{}  : $\O{1}$\\
\graphDel{}  : $\O{1}$\\
}
\end{frame}


\begin{frame}{Ideia inicial}
\begin{algorithm}[H]
\caption{\dymGraphQuery($G$, $u$, $v$)}
\label{Algo:dymGraphQuery}
\begin{algorithmic}[1]
\State \Return \dymForestQuery($G$.$F$, $u$, $v$)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{\dymGraphAddEdge($G$, $u$, $v$)}
\label{Algo:dymGraphAddEdge}
\begin{algorithmic}[1]
\If {\dymForestQuery($G.F$, $u$, $v$)}
\State \graphAdd($G$.$R$, $u$, $v$)
\Else 
\State \dymForestAddEdge($G.F$, $u$, $v$)
\EndIf
\end{algorithmic}
\end{algorithm}


\boxpurple{
\dymGraphQuery{} : $\O{\lg n}$\\
\dymGraphAddEdge{}  : $\O{\lg^2 n}$ amortizado\TODO{!!}
}
\end{frame}



\begin{frame}{Remoção de arestas}
\begin{block}{Busca por substituição de uma aresta}
\begin{itemize}
    \item Cada aresta possui um \defi{nível}, que é um inteiro entre~$1$ e $\lceil \log n \rceil$;
    \item Arestas serão inseridas no nível~$\lceil \log n \rceil$;
    \item O nível de uma aresta pode diminuir, mas nunca aumentar. 
\end{itemize}
\end{block}
\begin{block}{Estrutura}
$G_{\leqslant i}$: grafo com arestas de nível $\leqslant i$. Para cada camada $i$, manteremos:
\begin{itemize}
    \item $F_{\leqslant i}$: floresta maximal  de~$G_{\leqslant i}$; e
    \item $R_i$: arestas de nível~$i \notin F_{\leqslant i}$.
\end{itemize}
\end{block}
\begin{block}{Invariantes}
\begin{itemize}
    \item $F_{\leqslant i} \subseteq F_{\leqslant i+1}$, para cada $1\leqslant i \leqslant \lceil \log n \rceil-1$;
    \item $F_{\leqslant i}$ é uma floresta maximal de~$G_{\leqslant i}$; e
    \item Cada componente de $F_{\leqslant i}$ possui menos do que $2^i$ arestas.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Implementações}
\begin{exampleblock}{Adaptações}
\centering
$G.F\rightarrow G.F_{\leqslant \lceil \log n \rceil}$\\
$G.R\rightarrow G.R_{\lceil \log n \rceil}$
\end{exampleblock}
\begin{algorithm}[H]
\caption{\dymGraphDelEdge($G$, $u$, $v$)}
\label{Algo:dymGraphDelEdge}
\begin{algorithmic}[1]
\State $i$ $\gets$ \nivel[$u,v$]
\State \nivel[$u,v$] $\gets$ $\Nil$
\If {$uv$ $\in G.F_{\leqslant\lceil \lg n \rceil}$}\label{Algo:dymGraphDelEdge:linha:if}
\For {$j$ $\gets$ $i$ até $\lceil \lg n \rceil$}\label{linha2}
\State \dymForestDelEdge($G$.$F_{\leqslant j}$, $u$, $v$)
\EndFor
\State \dymGraphReplace($G$, $u$, $v$, $i$)
\Else
  \State \graphDel($G$.$R_i$, $u$, $v$)\label{Algo:dymGraphDelEdge:linha:removeLA}
\EndIf
\end{algorithmic}
\end{algorithm}
\boxpurple{
\centering
\dymGraphDelEdge{}  : $\O{\lg^2 n}$ amortizado.
}
\end{frame}

\begin{frame}{Estrutura de níveis}
\begin{figure}[htb]
\scalebox{.5}{
\input{fig/antes-rebaixar}
\input{fig/vazio}
\input{fig/depois-camada-alta}}
\end{figure}
\begin{figure}[htb]
\scalebox{.5}{
\input{fig/pontos}
\input{fig/vazio}
\input{fig/depois-camada-baixa}}
\end{figure}
\end{frame}




\begin{frame}{A rotina \dymGraphReplace{}}
\begin{algorithm}[H]
\caption{\dymGraphReplace($G$,$u$,$v$,$niv$)}
\label{Algo:dymGraphReplace}
\begin{algorithmic}[1]
\For {$i$ $\gets$ $niv$ até $\lceil \lg n \rceil$}\label{Algo:dymGraphReplace:linha:primeira}
\State $T_v$ $\gets$  \treapGetRoot($F_{\leqslant i}[v,v]$)
\State $T_u$ $\gets$  \treapGetRoot($F_{\leqslant i}[u,u]$)
\If {\treapGetSize($T_v$) < \treapGetSize($T_u$)}\Comment{Garantimos que $|T_v|\geqslant |T_u|$}
\State $u$ $\leftrightarrow$ $v$
\State $T_u \leftrightarrow T_v$
\EndIf
\For {$xy$ em $T_u$ com \nivel[x, y] = $i$}\label{Algo:dymGraphReplace:linha:moveTu}\Comment{Move $T_u$ para o nível $i-1$}
\State \nivel$[x,y]$ $\gets$ $i-1$ \label{Algo:dymGraphReplace:linha:moveTu2}
\State \dymForestAddEdge($G$.$F_{\leqslant i-1}$, $x$, $y$) \label{Algo:dymGraphReplace:linha:moveTu3}
\EndFor
\For {$xy$ em $G$.$R_i$ com $x$ em $T_u$}\label{Algo:dymGraphReplace:linha:achaSub}\Comment{Procura substituta para $uv$}
\State \graphDel($G$.$R_i$, $x$, $y$)
	\If {\textbf{não} \dymForestQuery($F_{\leqslant i}$, $x$, $y$}\label{Algo:dymGraphReplace:linhayinTv}
\For {$j \gets i$ até $\lceil \lg n \rceil$}\label{Algo:dymGraphReplace:linha:inseresub}
\State \dymForestAddEdge($G$.$F_{\leqslant j}$, $x$, $y$)
\EndFor
\State \Return
\Else
\State \nivel$[x,y]$ $\gets$ $i-1$ \label{Algo:dymGraphReplace:linha:rebaixar}
\State \graphAdd($G$.$R_{i-1}$, $x$, $y$) \label{Algo:dymGraphReplace:linha:rebaixar2}
\EndIf
\EndFor
\EndFor\label{Algo:dymGraphReplace:linha:ultima}
\end{algorithmic}
\end{algorithm}
\end{frame}

\begin{frame}{Implementação}
\begin{block}{}
\begin{itemize}
\item Implementamos HDT em Python3;
\item O código dessa implementação está livremente disponível;
\item O código \LaTeX do dissertão também está disponível.
\end{itemize}
\end{block}
\end{frame}

% --------------------------------------------------------------------- %
% Floresta maximal de peso mínimo em grafos planos ponderados dinâmicos %
% --------------------------------------------------------------------- %
\section[MSF]{Floresta maximal de peso mínimo em grafos planos ponderados dinâmicos}

\subsection{Definição do problema}
\begin{frame}{Grafo plano}
\begin{block}{Grafo plano}
Um \defi{grafo plano} é um grafo $G = (V, E)$ com as seguintes propriedades:
\begin{enumerate}
\item $V\subset \R^2$;
\item Toda aresta é um arco entre dois vértices;
\item O interior de uma aresta não contém vértices nem intersecta outras arestas.
\end{enumerate}
\end{block}
\begin{minipage}[H]{0.4\textwidth}
\begin{tabular}{| c | c |} 
 \hline
 aresta & peso\\
 \hline
 $a$ & 2 \\ 
 \hline
$b$ & 7 \\
 \hline
$c$ & 3 \\
 \hline
$d$ & 1 \\
 \hline
$f$ & 2 \\
 \hline
$g$ & 4 \\
 \hline
\end{tabular}
\end{minipage}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[H]
\scalebox{1}{
\input{fig/MSF-basico-0.tex}
	}
\end{figure}
\end{minipage}

\end{frame}




\begin{frame}{Grafo dual}
\begin{block}{Grafo dual}
Dado um grafo plano~$G$, o grafo \defi{dual} de~$G$ é o grafo $G^\star = (F,E^\star)$, onde
\begin{itemize}
\item $F$ é o conjunto de faces de~$G$;
\item $E^\star$ é o conjunto de arestas duais de~$G$.
\end{itemize}
\end{block}
\begin{figure}[H]
\scalebox{1.2}{
\centering
\input{fig/MSF-basico-1.tex}
}
\label{fig:MSF-basico-1}
\end{figure}
\end{frame}

\begin{frame}{Descrição combinatória plana}
%\begin{block}{Definição}
%Para cada vértice $v$ de um grafo plano~$G$, existe uma ordem cíclica~$D(v)$ das aresta incidentes a~$v$ obtida percorrendo as arestas incidentes a~$v$ em sentido anti-horário até retornar à aresta inicial do percurso.
%Uma \defi{descrição combinatória plana} de~$G$ é uma lista de todas essas ordens cíclicas.
%\end{block}
\begin{minipage}[H]{0.1\textwidth}
\begin{align*}
D(u)&=\langle (a,v), (b,v), (c,z)\rangle\\
D(v)&=\langle (a,u), (d,z), (b,u)  \rangle\\
D(z)&=\langle (c,u), (d,v), (g,y) \rangle \\
D(y)&=\langle (g,z), (f,y), (f,y) \rangle
\end{align*}
\begin{align*}
D(F_0)&=\langle (a^\star, F_2), (c^\star, F_1), \\
      &~~~~~~~(g^\star, F_0), (y^\star, F_3), \\
      &~~~~~~~(g^\star, F_0), (d^\star, F_1)\rangle\\
D(F_1)&=\langle (b^\star, F_2), (d^\star, F_0), (c^\star, F_0)  \rangle\\
D(F_2)&=\langle (a^\star, F_0), (b^\star, F_1)\rangle \\
D(F_3)&=\langle (f^\star, F_0)\rangle
\end{align*}
\end{minipage}
\hspace{-1cm}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[H]
\scalebox{1.2}{
\centering
\input{fig/MSF-basico-1.tex}
}
\label{fig:MSF-basico-1}
\end{figure}
\end{minipage}
\end{frame}

\begin{frame}{Floresta maximal de peso mínimo}
\begin{exampleblock}{O problema de floresta maximal de peso mínimo em grafos planos}
\begin{itemize}
\item \MSFCreate($n$): Cria e devolve um grafo plano ponderado~$G$ com $n$ vértices isolados.
\item \MSFaddEdge($G$, $e$, $u$, $e_u$, $v$, $e_v$, $w$): Insere em~$G$ uma nova aresta~$e$ com peso~$w$ ligando os vértices~$u$ e~$v$. A nova aresta~$e$ é sucessora das arestas~$e_u$ e~$e_v$ nas ordens cíclicas de~$u$ e~$v$, respectivamente.
\item \MSFdelEdge($G$, $e$): Remove a aresta~$e$ de~$G$.
\item \MSFupdate($G$, $e$, $w$): Altera o peso da aresta~$e$ de~$G$ para o valor~$w$.
\item \MSFweight($G$): Devolve o peso de uma MSF de $G$.
\end{itemize}
\end{exampleblock}

\begin{exampleblock}{Árvores dinâmicas planas}
Apresentaremos a solução proposta por Eppstein, Italiano, Tamassia, Tarjan, Westbrook e Yung para esse problema.
O nome da estrutura de dados introduzida por esses autores é \textit{edge-ordered dynamic tree} que traduzimos para \defi{árvores dinâmicas planas}.
\end{exampleblock}

\end{frame}

\begin{frame}{Árvore maximal e sua dual}
\begin{teorema}
\label{teo:MSFdual}
Seja~$T$ uma árvore geradora de um grafo plano conexo~$G$. O conjunto
$$
T^\star = \{e^\star:e\notin T\}
$$
é uma árvore geradora de~$G^\star$.
Além disso, se~$G$ for ponderado e adotarmos $w(e^\star) = w(e)$, então~$T$ será de peso mínimo em~$G$ se e somente se~$T^\star$ for de peso máximo em~$G^\star$.
\end{teorema}

\begin{figure}[H]
\scalebox{.6}{
\input{fig/MSF-basico-1.tex}
}
\scalebox{1}{
\input{fig/MSF-basico-2}
}
\end{figure}
\end{frame}



\begin{frame}{Árvores modificadas}
\begin{minipage}[H]{0.3\textwidth}
\centering
\begin{tabular}{| c  c |} 
 \hline
 vértices & pesos\\
 \hline
 $\hat a$, $\hat a_1$, $\hat a_3$ & 2 \\ 
 \hline
 $\hat b$, $\hat b_0$, $\hat b_2$ & 7 \\
 \hline
 $\hat c$, $\hat c_0$, $\hat c_2$ & 3 \\
 \hline
 $\hat d$, $\hat d_0$, $\hat d_2$ & 2 \\
 \hline
 $\hat f$, $\hat f_1$, $\hat f_3$ & 1 \\
 \hline
 $\hat g$, $\hat g_1$, $\hat g_3$ & 4 \\
 \hline
 $\hat u$, $\hat v$, $\hat y$, $\hat z$ & $-\infty$ \\
 \hline
 $\hat F_0$, $\hat F_1$, $\hat F_2$, $\hat F_3$ & $\infty$ \\
 \hline
\end{tabular}
\end{minipage}
\begin{minipage}[H]{0.5\textwidth}
    \centering
\scalebox{.7}{
\input{fig/MSF-basico-3}
}
\end{minipage}
\end{frame}

\begin{frame}{Exemplo de ADP}
\begin{figure}[htb]
\scalebox{1}{
\centering
\input{fig/MSF-basico-4}
}
\label{fig:MSF-figura-4}
\end{figure}
\end{frame}
\begin{frame}{Exemplo de ADP}
\begin{block}{Óctupla de $e$}
Há $8$ nós de link cut tree para cada aresta $e$ de~$G$.
Chamaremos esses~$8$ vértices de \defi{óctupla de $e$}.
\end{block}
\begin{figure}[htb]
\scalebox{1}{
\centering
\input{fig/MSF-octo}
}
\end{figure}
\end{frame}

%\subsection{Árvores dinâmicas planas}
%\begin{frame}{Árvores Dinâmicas Planas}
%\begin{exampleblock}{Biblioteca ADP}
%\begin{itemize}
%\item \LCOMakeOcto($e$, $w$): Recebe um identificador~$e$ e um peso~$w$ e cria e retorna uma óctupla de nós de ADP associados a~$e$ com peso~$w$.
%\item \LCODestroyOcto($H$, $e$): Recebe uma tabela de símbolos~$H$ e um identificador~$e$ e desaloca a óctupla associada a~$e$ da memória.
%
%\item \LCOConnected($p$, $q$): Retorna verdadeiro se os nós~$p$ e~$q$ estiverem na mesma ADP e falso caso contrário.
%\item \LCOFindNode($p$): Recebe um nó $p$ e retorna o vértice da~$\hat F$ que contêm $p$ em sua ordem cíclica.
%
%\item \LCOAddCost($p$, $w$): Atribui o peso~$w$ ao vértice que contém $p$ em sua ordem cíclica.
%\item \LCOMax($p$, $q$): Retorna o nó de peso máximo no percurso entre os nós~$p$ e~$q$.
%Essa operação assume que $p$ e~$q$ são nós da mesma ADP.
%\item \LCOMin($p$, $q$): Retorna o nó de peso mínimo no percurso entre os nós~$p$ e~$q$.
%Essa operação assume que~$p$ e~$q$ são nós da mesma ADP.
%\item \LCOCycle($p$): Permuta ciclicamente $D(u)$ de forma que o nó~$p$ seja o último na ordem.
%Se a ordem inicial tem forma $\alpha p \beta$, então a ordem resultante é $\beta\alpha p$.
%\item \treapPredecessor($p$): Retorna o predecessor do nó~$p$ na ordem cíclica.
%\end{itemize}
%\end{exampleblock}
%\end{frame}

\subsection{Resolvendo MSF com ADPs}
\begin{frame}{Criação de grafo plano ponderado dinâmico e obtenção de peso}
\begin{algorithm}[H]
\caption{\MSFCreate($n$)}
\label{Algo:MSFCreate}
\begin{algorithmic}[1]
\State $G.H$ $\gets$ \hashCreate($n$)
\State $G.p$ $\gets$ $0$
\State \Return $G$
\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
\caption{\MSFweight($G$)}
\label{Algo:MSFweight}
\begin{algorithmic}[1]
\State \Return $G$.$p$
\end{algorithmic}
\end{algorithm}
\boxpurple{
	\centering
	\MSFCreate:~$\O{n}$.\\
	\MSFweight:~$\O{1}$.\\
	\MSFaddEdge:~$\O{\lg m}$\\
	\MSFdelEdge:~$\O{\lg m}$.\\
	\MSFupdate:~$\O{\lg m}$.
}
\end{frame}
\begin{frame}{Execução de Mudança de peso \MSFupdate($G$, $a$, $5$)}
\begin{minipage}[H]{0.3\textwidth}
\begin{tabular}{| c | c |} 
 \hline
 aresta & peso\\
 \hline
 $a_i$ & 2 \\ 
 \hline
$b_i$ & 7 \\
 \hline
$c_i$ & 3 \\
 \hline
$d_i$ & 1 \\
 \hline
$f_i$ & 2 \\
 \hline
$g_i$ & 4 \\
 \hline
\end{tabular}
\end{minipage}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[!h]
\scalebox{1.045}{
\input{fig/MSF-antes-mudança-peso}
}
\end{figure}
\end{minipage}
\end{frame}

\begin{frame}{Execução de Mudança de peso \MSFupdate($G$, $a$, $5$)}
\begin{figure}[!h]
\scalebox{1.4}{
\input{fig/MSF-basico-5}
}
\end{figure}
\end{frame}


\begin{frame}{Execução de Mudança de peso \MSFupdate($G$, $a$, $5$)}
\begin{figure}[!h]
\scalebox{1}{
\input{fig/MSF-basico-6}
}
\end{figure}
\end{frame}



\begin{frame}{Execução de Mudança de peso \MSFupdate($G$, $a$, $5$)}
\begin{figure}[htb]
\scalebox{1}{
\centering
\input{fig/MSF-basico-7}
}
\end{figure}
\end{frame}





\begin{frame}{Dois casos de remoção de aresta}
\begin{figure}[htb]
\scalebox{0.7}{
\input{fig/MSF-basico-1.tex}
}
\end{figure}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[htb]
\scalebox{0.7}{
\input{fig/MSF-remove-ponte.tex}
}
\end{figure}
\end{minipage}
\begin{minipage}[H]{0.4\textwidth}
\begin{figure}[htb]
\scalebox{0.7}{
\input{fig/MSF-remove-nao-ponte}
}
\end{figure}
\end{minipage}
\end{frame}

\begin{frame}{Remoção de ponte}
\begin{figure}
\input{fig/MSF-ordem-ciclica-ponte}
\end{figure}
\end{frame}

\begin{frame}{Remoção de ponte - \MSFdelEdge($G$, $g$)}
\begin{figure}
\input{fig/MSF-remove-sem-e1}
\end{figure}
\end{frame}

\begin{frame}{Remoção de não ponte}
\begin{minipage}{.45\textwidth}
\begin{figure}[h!]
\scalebox{.85}{
\input{fig/MSF-ordem-ciclica-nao-ponte}
}
\end{figure}
\end{minipage}
\hfill
\begin{minipage}{.42\textwidth}
\begin{figure}[h!]
\scalebox{.85}{
\input{fig/MSF-ordem-ciclica-nao-ponte-depois}
}
\end{figure}
\end{minipage}
\end{frame}

\begin{frame}{Remoção de não ponte - \MSFdelEdge($G$, $b$)}
\begin{figure}[H]
\scalebox{1.25}{
\input{fig/MSF-remove-aresta-ex-1}
}
\end{figure}
\end{frame}
\begin{frame}{Remoção de não ponte - \MSFdelEdge($G$, $b$)}
\begin{figure}
\input{fig/MSF-remove-aresta-ex-2}
\end{figure}
\end{frame}

\begin{frame}{Remoção de não ponte - \MSFdelEdge($G$, $b$)}
\begin{figure}
\input{fig/MSF-remove-aresta-ex-3}
\end{figure}
\end{frame}


\begin{frame}{Dois casos de adição de aresta}
\begin{minipage}{0.4\textwidth}
\begin{figure}
\scalebox{0.7}{
\input{fig/MSF-antes-adiciona-ponte}
}
\end{figure}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{figure}
\scalebox{0.7}{
\input{fig/MSF-adiciona-ponte.tex}
}
\end{figure}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{figure}
\scalebox{0.7}{
\input{fig/MSF-antes-adiciona-nao-ponte.tex}
}
\end{figure}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{figure}
\scalebox{0.7}{
\input{fig/MSF-adiciona-nao-ponte}
}
\end{figure}
\end{minipage}
\end{frame}


\begin{frame}{Adição de aresta - \MSFaddEdge($G$, $h$, $v$, $a$, $y$, $f$, $7$)}
\begin{figure}
\scalebox{1}{
\input{fig/MSF-adiciona-ponte-1}
}
\end{figure}
\end{frame}

\begin{frame}{Adição de aresta - \MSFaddEdge($G$, $h$, $v$, $a$, $y$, $f$, $7$)}
\begin{figure}[htb]
\scalebox{1}{
\input{fig/MSF-adiciona-ponte-2}
	}
\end{figure}
\end{frame}

\begin{frame}{Adição de aresta - \MSFaddEdge($G$, $h$, $v$, $a$, $y$, $f$, $7$)}
\begin{figure}[htb]
\scalebox{1}{
\input{fig/MSF-adiciona-ponte-3}
}
\end{figure}
\end{frame}

\begin{frame}{Adição de aresta - \MSFaddEdge($G$, $h$, $v$, $a$, $y$, $f$, $7$)}
\begin{figure}[htb]
\scalebox{1}{
\input{fig/MSF-basico-4}
}
\end{figure}
\end{frame}

\begin{frame}{Adição de aresta - \MSFaddEdge($G$, $h$, $v$, $a$, $y$, $f$, $7$)}
\begin{figure}[htb]
\scalebox{.9}{
\input{fig/MSF-adiciona-nao-ponte-1}
}
\label{fig:MSF-adiciona-nao-ponte-1}
\end{figure}
\end{frame}


\begin{frame}{Adição de aresta - \MSFaddEdge($G$, $h$, $v$, $a$, $y$, $f$, $7$)}
\begin{figure}
\scalebox{.95}{
\input{fig/MSF-adiciona-nao-ponte-2}
}
\end{figure}
\end{frame}






\section[$\Omega(\lg n)$]{O limitante inferior de~$\Omega(\lg n)$}

\begin{frame}{O limitante inferior de~$\Omega(\lg n)$}
Mihai Patrascu e Erik D. Demaine provaram o seguinte limitante inferior:
\begin{teorema}
Seja $t_m$ o consumo de tempo de \dymGraphAddEdge{} ou \dymGraphDelEdge{} e~$t_c$ o consumo de tempo de \dymGraphQuery{}, então
$$
\min\{ t_m, t_c\}\lg \left( \frac{\max\{ t_m, t_c\}}{\min\{ t_m,t_c\}}\right) = \Omega(\lg n).
$$
Esse limitante é válido mesmo para implementações aleatorizadas e/ou amortizadas de \dymGraphAddEdge{}, \dymGraphDelEdge{} e \dymGraphQuery{} e mesmo restringindo a classe de grafos do problema para caminhos.
\end{teorema}
\end{frame}

\section{Bibliografia}
\nocite{*}
\begin{frame}[allowframebreaks]
\frametitle{Bibliografia}
\bibliographystyle{plain}
    \bibliography{bib.bib}
\end{frame}

\end{document}
